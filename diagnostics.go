// Package diagnostics provides facilities for running tests and checks of a network or system.
package diagnostics

import (
	"reflect"
	"sync"

	ping "github.com/sparrc/go-ping"
)

const (
	// The version encoded in reports. This only needs to change if breaking changes are made to the
	// report structure. This version applies to the top-level report and all sub-reports.
	reportVersion = 1
)

// Config for running diagnostics.
type Config struct {
	// PingConfig, if non-nil, defines how the ping test should be run.
	PingConfig *PingConfig
}

// PingConfig defines configuration for diagnostics run using an ICMP ping utility.
type PingConfig struct {
	Addresses []string

	// Count is the number of packets sent per address. Defaults to 1.
	Count int
}

func (cfg PingConfig) count() int {
	if cfg.Count <= 0 {
		return 1
	}
	return cfg.Count
}

// The report sturctures below define how diagnostic reports are encoded. All structs represented as
// fields and sub-fields of Report should be JSON-friendly. Care should be taken to avoid making
// breaking changes to the structure of any of these reports. If necessary, bump the reportVersion
// constant.

// Report generated by Run. This structure is designed to be JSON-friendly.
type Report struct {
	// Version is used when decoding the report. This only needs to change if breaking changes are
	// made to the report structure. Version applies to the top-level report and all sub-reports.
	Version int

	Ping *PingReport `json:",omitempty"`
}

// Run a full diagnostics report.
func Run(cfg Config) Report {
	r := Report{Version: reportVersion}
	if cfg.PingConfig != nil {
		pingReport := RunPingTest(*cfg.PingConfig)
		r.Ping = &pingReport
	}
	return r
}

// HasErrors returns true if this report contains any errors.
func (rp Report) HasErrors() bool {
	return hasErrors(rp)
}

// PingReport is part of the NetworkReport.
type PingReport struct {
	// Statistics is a map of addresses to PingStatistics.
	Statistics map[string]PingStatistics `json:",omitempty"`

	// If there is an error, the statistics map may be nil.
	Error *string `json:",omitempty"`
}

// PingStatistics represents statistics about a ping test.
type PingStatistics struct {
	ping.Statistics `json:",omitempty"`

	// If there is an error, the statistics may not be reliable or meaningful.
	Error *string `json:",omitempty"`
}

// RunPingTest runs a diagnostic using ICMP pings. Requires root permissions on Unix systems.
func RunPingTest(cfg PingConfig) PingReport {
	var (
		stats = make(chan PingStatistics, len(cfg.Addresses))
		wg    = new(sync.WaitGroup)
	)
	for _, a := range cfg.Addresses {
		wg.Add(1)
		go func(addr string) {
			defer wg.Done()
			p, err := ping.NewPinger(addr)
			if err != nil {
				stats <- PingStatistics{Error: sPtr(err.Error()), Statistics: ping.Statistics{Addr: addr}}
				return
			}
			p.Count = cfg.count()
			p.SetPrivileged(true)
			p.Run()
			stats <- PingStatistics{Statistics: *p.Statistics()}
		}(a)
	}
	wg.Wait()
	close(stats)

	statsMap := map[string]PingStatistics{}
	for s := range stats {
		statsMap[s.Addr] = s
	}
	return PingReport{statsMap, nil}
}

// Returns true iff v has any non-nil fields or subfields named "Error".
func hasErrors(v interface{}) bool {
	reflected := reflect.Indirect(reflect.ValueOf(v))
	switch reflected.Kind() {
	case reflect.Struct:
		for i := 0; i < reflected.NumField(); i++ {
			if reflected.Type().Field(i).Name == "Error" && !reflected.Field(i).IsNil() {
				return true
			}
			if hasErrors(reflected.Field(i).Interface()) {
				return true
			}
		}
		return false

	case reflect.Map:
		iter := reflected.MapRange()
		for iter.Next() {
			if hasErrors(iter.Value().Interface()) {
				return true
			}
		}
		return false

	default:
		return false
	}
}

func sPtr(s string) *string {
	return &s
}
